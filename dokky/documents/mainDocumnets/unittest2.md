## 테스트 코드 작성 설계가 필요한 이유

 	- 무작정 뛰어들어 하기보다 방향을 제대로 잡고 가야 효율성을 살릴 수 있다.
 	- 코딩하고, 또 다시 고치기 위한 작업을 최소화 하기 위해 처음에 방향성을 잘 잡아보자

## 단위 테스트를 작성해야 하는 이유

 	- 예상한 대로, 의도한 대로 작동하는지 알고 싶기 때문
 	- 현재 동작을 더 잘 이해하고 싶기 때문
 	- 자신과 다른 사람들이 나중에 이해하도록 하고 싶기 때문
 	- 다른사람이 같은 영역의 코드를 변경할때도 테스트가 필요하기 때문
 	- 코드를 변경하고 그것으로 변경된 사항이 기존 동작을 깨뜨리지 않았는지 확인하고 싶기 때문
 	- 프로덕션 시스템 배포에 대한 자신감을 높여주기 때문
 	- 문제가 있다면 즉시 중단하고 고칠수 있고, 문제의 발견이 쉽기 때문

## 테스트의 방향성
 	
 	- 코드 결함을 찾는 것도 중요하지만 테스트는 결국 더 좋은 소프트웨어와 코드 품질을 갖도록 도와주어야 한다.
 	- 유지하기 힘들고 별로 가치 없는 테스트 코드가 아닌 올바른 방법으로 가치 있는 단위 테스트를 만들수 있도록
 	- 테스트를 더 단순하게 작성할 수 있도록 테스트 코드를 정기적으로 정리 필요  	
 	- 작은 양의 코드로 테스트를 만들기

### 1) 독립성

- 테스트는 상호 의존성이 없어야 한다. 독립적이어야함
- 안그러면 테스트 실패시 실패 이유를 찾기 위해 엄청난 노력 필요 하거나 이전에 실행된 모든 테스트를 살펴야하는 문제가 생겨버린다
- 어떤 테스트 코드가 다른 테스트에 영향을 주는것을 최소화 static 필드를 피해야한다.
- 모든 테스트를 독립적으로 만들기 위해 테스트마다 새로운 인스턴스를 생성
- 만약 동일한 인스턴스에서 실행된다면 공유된 객체의 상태를 정리하는것도 걱정해야하기 때문

### 2) 단위 테스트 크기
 	
 	- 단위 크기는 명확하게 정의 하지 않았기 때문에, 이 단위를 유용한 행동을 하는 작은 코드로 볼것
 	- 이 단위 자체는 완전한 끝에서 끝까지 행동을 의미하지는 않는다.
 	- 그 대신 이러한 끝에서 끝까지의 행동에서 작은 부분 집합으로 보자

### 3) 테스트 구조,배치 AAA

 	- Arrange : 테스트 에서는 어떤 것을 하기 위해서는 먼저 테스트 상태를 설정하는 준비 단계의 일들을 해야함
 	테스트 코드를 실행하기 전에 시스템이 적절한 상태에 있는지 확인, 객체들을 생성하거나 , 다른 api를 호출하는것등

 	- Act : 테스트를 준비한 후에는, 검증하려는 코드인 메서드를 실행, 보통은 단일 메서드를 호출

 	- Assert : 마지막으로 기대하는 결과를 단언
 	실행하는 코드가 기대한 대로 동작하는지 확인, 실행한 코드의 반환값 혹은 그외 필요한 객체들의 새로운 상태를 검사


### 4) 중복 로직 제거 

@Before어노테이션으로 표시된 메서드를 먼저 실행
 (공통적인 초기화 코드)예시 객체의 초기화  > 가독성 향상, 효율을 높임
 
## JUnit 단언

- 단언은 어떤 조건이 참인지 검증하는 방법, 참이 아니면 테스트는 실패

- 단언의 방법
- 전통적인 스타일의 단언
- hamcrest 단언
- hamcrest 단언의 예시 :   
- assertThat() 정적 메서드는 명확한 값을 비교한다
- 일반적인 단언보다 hamcrest 단언이 실패할 경우에 오류 메시지에서 더많은 정보를 알 수 있음
- 스택 트레이스에서 더욱 자세한 정보를 얻을수있다.
- 매처를 몇개만 사용해도 되지만, 더 많은 햄크레스트 매처를 도입할수록 테스트 코드의 표현력이 깊어짐

- 테스트를 코드 자체만으로 이해할수 있게 작성하기
- 테스트 이름을 변경하거나
- 의미있는 이름을 가진 도우미 메서드로 추출하거나
- 가독성이 우수한 햄크레스트 단언을 사용하거나
- 하지만 전통적인 스타일의 단언과 hamcrest단언은 상충 관계이기도 하다 왜냐하면 
hamcrest단언은 군더더기 있는 코드를 만들 수도 있기 때문..

## 예외 테스트
JUnit을 이용하여 유닛 테스트를 하다 보면 예외를 테스트 해야 하는 경우가 있다.

JUnit은 예외를 잡으면 테스트 실패가 아니라 테스트 error로 보고한다.


## 테스트 구조화 조직

테스트 코드를 잘 조직하고 구조화 할 수 있어야 한다.

- 준비 실행 단언을 사용하여 테스트를 가시적이고 일관성 있게 만드는 방법

 	aaa로 테스트 일관성 유지
  	가시적으로 준비 실행 단언 부분으로 조직했슴 이것을 트리플 a라고도 함 
 	aaa는 앞으로 작성할 모든 테스트 코드에 해당

- 메서드를 테스트 하는 것이 아니라 동작을 테스트 하여 테스트 코드의 유지 보수성읖 높이는 방법

 	동작 테스트 vs 메서드 테스트
 	테스트를 작성할때는 클래스 동작에 집중해야 하며 개별 메서드를 테스트 한다고 생각하면 안된다
 	단위 테스트를 작성할때는 먼저 전체적인 시각에서 시작해야 한다.
 	개별 메서드를 테스트 하는것이 아니라 클래스의 종합적인 동작을 테스트 해야 한다.

- 테스트는 고립시켜야 한다

 	하나의 메소드에 테스트를 집중하게되면
 	공통초기화의 부담을 줄일수 잇지만 테스트고립의 중요한 이점을 잃게됨
 	테스트를 여러개로 분리하면
 	단언이 실패했을때 실패한 테스트 이름이 표시되기 때문에 어느 동작에서
 	문제가 있는 빠르게 파악가능
 	실패한 테스트를 해독하는데 필요한 시간을 줄일수 있음
 	현재 실패한 테스트에 대해 다른 테스트의 영향을 제거가능

-  문서로서의 테스트

단위 테스트는 우리가 만드는 클래스에 대한 지속적이고 믿을 수 있는 문서 역할을 해야한다.
테스트는 코드 자체로 쉽게 설명할 수 없는 가능성들을 알려준다.
어떤 의믜에서는 테스트가 없었으면 주석으로 적어 놓았을 많은 내용을 보충하기도 한다.

1) 일관성있는 이름으로 테스트 문서화
테스트 케이스를 단일 메서드로 결합할수록 테스트 이름 또한 일반적이고 의미를 잃어 간다.
좀 더 작은 테스트로 이동할수록 각각은 분명한 행동에 집중한다.
또 각 테스트 이름에 더 많은 의미를 부여할 수 있다. 
주요 목표는 테스트 코드를 다른 사람에게 의미 있게 만드는것

2) 테스트를  의미 있게 만들기
다른 사람이 테스트가 어떤 일을 하는지 파악하기 어려워 한다면 주석을 추가하는것만으로
끝내지말고 테스트 이름을 개선해야 한다. 
지역 변수 이름 개선하기
의미 있는 상수 도입하기
햄크레스트 단언 사용하기
커다란 테스트를 작게 나누어 집중적인 테스트 만들기
테스트 군더더기들을 도우미 메서드와 @BEFORE 메서드로 이동하기

테스트 이름과 코드를 재작업하여 부가적으로 주석을 넣지 않고도 스토리를 알수 있도록


- @before 와 @after 애노테이션을 활용하여 공통 초기화 및 정리 코드를 설정하는 방법

 	@Before 와 @After(공통 초기화와 정리) 더 알기
 	중복된 초기화 코드를 제거 , setup 메서드라고도 함
 	유지보수에 좋음
 	@Before 메소드도 여러개 만들어 테스트 실행전에 여러개 동작하게끔
 	하나의 메서드에 결합하기보다 여러개로 분할을 하자 그게좋다
 	문제는 이Before메소드도 실행순서는 보장하지 않는다.
 	순서가 필요할땐 결합을 해야함

 	After메서드는 클래스에 있는 각 테스트를 동작후 실행
 	테스트가 실패하더라도 실행됨
 	예를들어 열려있는 데이터베이스 연결을 종료

 	@BeforeClass
 	이것은 클래스에 있는 어떤 테스트들을  실행하기 전에 딱 한번만 실행

 	@AfterClass
 	실행후 딱 한번 실행

- 거슬리는 테스트를 안전하게 무시하는 방법

 	@Ignore("ㅇㅇ") 주석처리하지말고 이렇게 애노테이션을 달아 무시하자
 	그래야 나중에 다시보게되지 주석처리하면 보지않음


- 잘못된 테스트
 	테스트를 사용하는 사람에게 어떤 정보도 주지못하는 테스트
 	실행하는데 오래 걸리는 테스트
 	어떤 가치도 증명하지 못하는 테스트
 	코드를 충분히 커버하지 못하는 테스트
 	구현과 강하게 결합되어 있는 테스트 , 따라서 작은 변화에도 다수의 테스트가 깨진다


- 좋은 테스트의 first 속성

 	Fast 빠른
 	Isolated 고립된
 	Repeatable 반복가능한
 	Self-validating 스스로 검증 가능한
 	Timely 적시의

fast
	
 	느린것에 의존하는 코드를 최소화 한다면 작성하기 쉬워짐
 	이러한 의존성을 최소화하는것 역시 좋은 설계의 목표
 	코드를 클린 객체 지향

Isolated 고립된

 	좋은 단위 테스트는 검증하려는 작은 양의 코드에 집중한다
 	이게 단위라고 말하는 정의와 부합한다
 	직접적 혹은 간접적으로 테스트 코드와 상호 작용하는 코드가 많을수록
 	문제가 발생할 소지가 늘어난다
 	테스트 대상 코드는 데이터베이스를 읽는 다른 코드와 상호작용할수도있음
 	데이터 의존성을 많은 문제를 만듬
 	궁극적으로 데이터베이스에 의존해야 하는 테스트는 디비가 올바른 데이터를 
 	가지고있는지 확인해야 한다. 데이터 소스를 공유한다면 테스트를 깨뜨리는 외부 변화도
 	걱정해야 한다. 가용성 혹은 접근성 이슈로 실패할 가능성이 증가
 	좋은 단위테스트는 다른 단위 테스트에 의존하지 않는다.

 	여러 테스트가 생성된 데이터를 재사용하는 방식으로 테스트 순서를 조작하여
 	전체 테스트의 실행 속도를 높이려고 할수도있지만 이렇게 하면 의존성의 악순환만
 	동시에 발생 일이 잘못되면 테스트가 실패했을때 앞선 이벤트에서 무엇이 원인인지
 	알아내르라 더 긴시간 소모

 	따라서 테스트 코드는 어떤 순서나 시간에 관계없이 실행할수 있어야함
 	각 테스트가 작은양의 동작에만 집중하면 테스트 코드를 집중적이고 독립적으로 유지하기 쉬워짐

Repeatable 반복가능한
 	좋은 테스트는 반복 가능해야 한다.
 	실행할때마다 결과가 같아야 한다. 직접 통제할수 없는 외부 환경에 있는 항목들과 격리시켜야 한다
	예를 들어 시간변화에 독립성 유지 	

Self-validating 스스로 검증 가능한

 	자동화 테스트에 필요한 설정단계 자동화
	테스트를 언제 어떻게 실행할지도 자동화
 	이클립스의 infinitest같은 도구 > 시스템이 변경되면 infinitest는 이들을 식별하고
 	백드라운드로 잠재적으로 영향을 받는 테스트들을 실행
 	좀더 큰 규모에서는 젠킨스 같은 지속적 통합 ci 도구를 사용
 	ci도구가 소스 저장소를 관찰하여 변화를 감지하면 빌드와 테스트 절차를 시작
 	코드를 소스 저장소에 통합할때마다 빌드가 자동으로 수행되고 모든 테스트를 실행

 	테스트 결과를 수동으로 검증하는 것은 시간 소모적인 절차이고
 	리스크가 늘어난다. 멍해지기 쉽고 코드가 출력해 내는 거대한 로그를 보다가
 	중요한 신호를 놓칠수도 있다

 	테스트는 기대하는 것이 무엇인지 단언하지 않으면 테스트가 아니다
 	단위 테스트는 시간을 소모하기보다는 절약한다

Timely 적시의

 	적절한 순가에 단위 테스트에 집중하는것이 낫다
 	적시에 단위 테스트를 작성하는 습관
 	옛날 코드에 대한 테스트는 시간 낭비가 될수 있다
 	코드에 큰 결함이 없고 당장 변경할 예정이 없다면 시간낭비가 될수있다
 	좀 더 변화가많고 말썽이 많을것 같은 부분에 투자


테스트 주도개발
테스트를 먼저 작성하고 코드를 작성하면 이전과 다른 더 좋은결과
많은사람이 이를 가리켜 테스트 주도개발 tdd

일반적인 단위 테스트와 tdd차이점은 tdd에서는 테스트를 먼저 작성
먼저 작성하든 이후에 작성하든 first 원리를 고수하면 됨

고민사항
1.단위 테스트 개념은 도대체 어느정도로 작게 유지해야하는가?의문이다..
이에 대해 아직 감이 없다.. 테스트를 얼마나 작게 분할할.것인가?

1. 하나의 메소드안에 고립을 시키는것
2. 메소드안에서 코드의 양이적고 범위를 좁혀야하는것..

2. 내가하고싶은건 통합테스트인것인가?아니면 단위테스트인것인가?
단위테스트가 테스트하는 범위가 굉장히 좁다면 나는 통합테스트를 하고싶었던것인가?



### Right-BICEP 무엇을 테스트 할 것인가?

Right 결과가 올바른가?

테스트 코드는 무엇보다도 기대한 결과를 산출하는지 검증할 수 있어야 한다

B 경계조건(boundary conditions)은 맞는가?

경계조건에서는 CORRECT를 기억하라

I 역 관계(inverse relationship)를 검사할 수 있는가?

C 다른 수단을 활용하여 교차 검사(cross-check)할 수 있는가?

E 오류 조건을(error conditions) 강제로 일어나게 할 수 있는가?

p 성능 조건(performance characteristics)은 기준에 부합하는가?


 참고도서 : 자바와 JUnit을 활용한 실용주의 단위 테스트



  

 


 